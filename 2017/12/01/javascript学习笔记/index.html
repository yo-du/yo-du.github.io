<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="探寻设计的尺度"><title>javascript学习笔记 | 有度</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="header-limit"><div class="site-name"><h1 class="hidden">javascript学习笔记</h1><a class="logo-brand" href="/." rel="home"><img class="logo nofancybox" src="/img/logo.svg" alt="yodu"></a></div><div id="nav-menu"><a href="/."><i class="fa null"> 首页</i></a><a href="/categories/设计/"><i class="fa null"> 设计</i></a><a href="/categories/编程/"><i class="fa null"> 编程</i></a><a href="/categories/随笔/"><i class="fa null"> 随笔</i></a><a href="/about/"><i class="fa null"> 关于</i></a></div></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">javascript学习笔记</h1><div class="post-meta">2017-12-01<span class="category"><a href="/categories/编程/">编程</a></span></div><div class="clear"><div class="toc-article" id="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#js基础语法"><span class="toc-text">js基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串处理"><span class="toc-text">字符串处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日期时间-☍"><span class="toc-text">日期时间 ☍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单线程、同步、异步"><span class="toc-text">单线程、同步、异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型判断-☍"><span class="toc-text">类型判断 ☍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小数位保留"><span class="toc-text">小数位保留</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6（ES2015）"><span class="toc-text">ES6（ES2015）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展运算符（…）☍"><span class="toc-text">扩展运算符（…）☍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise对象-☍"><span class="toc-text">Promise对象 ☍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator（遍历器）-☍"><span class="toc-text">Iterator（遍历器） ☍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-☍"><span class="toc-text">async ☍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量名转字符串"><span class="toc-text">变量名转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延时"><span class="toc-text">延时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-☍"><span class="toc-text">JSON ☍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延时（setTimeout）"><span class="toc-text">延时（setTimeout）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件目录操作"><span class="toc-text">文件目录操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架、库"><span class="toc-text">框架、库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-对比-react"><span class="toc-text">vue 对比 react</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程"><span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试"><span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#console-log"><span class="toc-text">console.log()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单元测试-☍-☍"><span class="toc-text">单元测试 ☍ ☍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#端到端测试"><span class="toc-text">端到端测试</span></a></li></ol></li></ol></div></div><div class="post-content"><p><img src="/-media/javascript学习笔记/190504-182600.png" alt="190504-182600"></p>
<h2 id="js基础语法"><a href="#js基础语法" class="headerlink" title="js基础语法"></a>js基础语法</h2><h4 id="变量提升（-hoisting-）"><a href="#变量提升（-hoisting-）" class="headerlink" title="变量提升（ hoisting ）"></a>变量提升（ <strong>hoisting</strong> ）</h4><p>使用 <code>var</code> 关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTML的注释标签: &lt;!--  --&gt;</span><br><span class="line"></span><br><span class="line">CSS的注释标签: /* */</span><br><span class="line"></span><br><span class="line">JS的注释标签:  /* */（注释代码块）、//（注释单行）</span><br></pre></td></tr></table></figure>
<h4 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theText = <span class="built_in">document</span>.getElementById(<span class="string">'mytext'</span>).value	<span class="comment">//获取输入框的内容</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'mytext'</span>).value=<span class="string">"aaaa"</span>;		<span class="comment">//设置输入框的内容为aaaa</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&apos;ab&apos;, &apos;cd&apos;, &apos;ef&apos;]</span><br><span class="line">// 原生方法</span><br><span class="line">arr.splice(arr.findIndex(item =&gt; item === &apos;cd&apos;), 1) </span><br><span class="line"></span><br><span class="line">// lodash方法</span><br><span class="line">import _ from &apos;lodash&apos;</span><br><span class="line">_.pull(arr, &apos;cd&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><h4 id="截取片段"><a href="#截取片段" class="headerlink" title="截取片段"></a>截取片段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcdef'</span>.slice(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// 得到前4个字符</span></span><br></pre></td></tr></table></figure>
<h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mdText = mdText.split(<span class="string">".jpg"</span>).join(<span class="string">".jpg-A"</span>)		<span class="comment">//*推荐 替换所有 缺点：无法不分大小写</span></span><br><span class="line">mdText = mdText.replace(<span class="string">".jpg"</span>,<span class="string">".jpg-A"</span>)			<span class="comment">//只能替换第一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mdText = mdText.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">".jpg"</span>,<span class="string">'ig'</span>),<span class="string">".jpg-A"</span>);	</span><br><span class="line"><span class="comment">//替换所有， 存在问题：有特殊符号需要转义，如'('，需写成'\\(' ;'ig'中i表示不分大小写，g是全部替换；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数替换所有</span></span><br><span class="line"><span class="built_in">String</span>.prototype.replaceAll = <span class="function"><span class="keyword">function</span> (<span class="params">FindText, RepText</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(FindText,<span class="string">'g'</span>);  <span class="comment">//创建正则RegExp对象,g标识全文匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(regExp, RepText);  </span><br><span class="line">&#125;;  </span><br><span class="line">mdText = mdText.replaceAll(<span class="string">".jpg"</span>,<span class="string">".jpg-A"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="数字和字符串转换"><a href="#数字和字符串转换" class="headerlink" title="数字和字符串转换"></a>数字和字符串转换</h4><h5 id="数字转字符串-☍"><a href="#数字转字符串-☍" class="headerlink" title="数字转字符串 ☍"></a>数字转字符串 <a href="https://www.cnblogs.com/fozero/p/6959896.html" target="_blank" rel="noopener"><strong>☍</strong></a></h5><p>“” + value ，加法运算符配合一个空字符串可以把任意值转换为字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">''</span> + <span class="number">23</span>  <span class="comment">// ’23‘</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于数字补0</span></span><br><span class="line"><span class="keyword">let</span> countStr = (<span class="string">'00000'</span> + count).slice(<span class="number">-6</span>)  <span class="comment">// 取字符串的倒数第6位到最后一位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrefixInteger</span>(<span class="params">num, length</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (<span class="built_in">Array</span>(length).join(<span class="string">'0'</span>) + num).slice(-length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value.toString() </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">x = n.toString()  <span class="comment">// 不能把null和undefined转换为字符串</span></span><br></pre></td></tr></table></figure>
<p>String(value)</p>
<p>要让数字更加显式地转换为字符串,可以使用String()函数</p>
<h5 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parseInt() 函数从string的开始解析，返回一个整数</span><br><span class="line">parseInt(&apos;123&apos;) : 返回 123；</span><br><span class="line">parseInt(&apos;1234xxx&apos;) : 返回 1234；</span><br><span class="line">parseInt(&apos;123.456&apos;) : 返回 123；</span><br><span class="line">parseInt(&apos;1 2 3&apos;) : 返回 1；字符串的情况，自会返回第一个数</span><br><span class="line">parseInt(&apos;bb cc 12&apos;) : 返回 NaN；字符串第一个不是数，返回nan</span><br><span class="line">parseInt(&apos;123&apos; 321) : 返回 321；</span><br><span class="line">parseInt(&quot;AF&quot;, 16); 返回 175；会自动把二进制十六进制八进制的转化成数字</span><br><span class="line"></span><br><span class="line">如果解析不到数字，则将返回一个NaN的值，可以用isNaN()函数来检测；</span><br><span class="line"></span><br><span class="line">parseFloat()只会返回小数</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式-☍"><a href="#正则表达式-☍" class="headerlink" title="正则表达式 ☍"></a>正则表达式 <a href="https://juejin.im/post/5b5db5b8e51d4519155720d2" target="_blank" rel="noopener">☍</a></h4><table>
<thead>
<tr>
<th>single char</th>
<th>quantifiers(数量)</th>
<th>position(位置)</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d 匹配数字</td>
<td>* 0个或者更多</td>
<td>^一行的开头</td>
</tr>
<tr>
<td>\w  匹配word(数字、字母)</td>
<td>+ 1个或更多，至少1个</td>
<td>$一行的结尾</td>
</tr>
<tr>
<td>\W 匹配<strong>非</strong>word(数字、字母)</td>
<td>? 0个或1个,一个Optional</td>
<td>\b 单词”结界”(word bounds)</td>
</tr>
<tr>
<td>\s 匹配white space(包括空格、tab等)</td>
<td>{min,max}出现次数在一个范围内</td>
<td></td>
</tr>
<tr>
<td>\S 匹配<strong>非</strong>white space(包括空格、tab等)</td>
<td>{n}匹配出现n次的</td>
<td></td>
</tr>
<tr>
<td>. 匹配任何，任何的字符</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>[]</code> 表示或的逻辑；</p>
<p><code>/[-.(]/</code>  <code>-</code>放在第一位表示连字符本身，放在中间，表示”从..到..”，比如<code>[a-z]</code>表示a-z</p>
<p><code>[.)]</code> 括号中的特殊符号不需要转义，就表示其本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^ab]` 括号中的`^`表示非，anythings except `a` and `b</span><br></pre></td></tr></table></figure>
<p><code>(a|b)</code>也可表示选择</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = <span class="string">'2018-2-8 21:1:32'</span> </span><br><span class="line"><span class="keyword">let</span> a = time.split(<span class="regexp">/[-:]/</span>)		<span class="comment">//匹配'-'或':'	</span></span><br><span class="line"></span><br><span class="line">replace(<span class="regexp">/(^\d&#123;2&#125;|\d&#123;3&#125;$)/</span>, <span class="string">''</span>)  <span class="comment">//替换开头的2位数字</span></span><br><span class="line">replace(<span class="regexp">/:\d&#123;1,2&#125;$/</span>, <span class="string">''</span>)	<span class="comment">//替换从结尾开始，:后面的1到2位数字</span></span><br></pre></td></tr></table></figure>
<h3 id="日期时间-☍"><a href="#日期时间-☍" class="headerlink" title="日期时间 ☍"></a>日期时间 <a href="https://wangdoc.com/javascript/stdlib/date.html" target="_blank" rel="noopener">☍</a></h3><h4 id="时间标准-☍"><a href="#时间标准-☍" class="headerlink" title="时间标准 ☍"></a>时间标准 <a href="https://www.zhihu.com/question/27052407/answer/56923233" target="_blank" rel="noopener">☍</a></h4><p>UTC为国际标准时间，是根据原子钟来计算时间，更精确</p>
<p>GMT（格林威治时间）是根据地球的自转和公转来计算时间，自转在缓慢变慢</p>
<p>GMT和UTC的时间可看成一样，虽然有很小的误差；</p>
<h4 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h4><p>ISO-8601 标准格式：2019-04-20T06:20:54.513Z</p>
<p>GMT格式：Sat Apr 20 2019 14:20:54 GMT+0800 (CST)</p>
<p>UNIX时间（POSIX时间）：从国际标准时间 1970年1月1日0时0分0秒起至现在的总秒数，如：1555741254000</p>
<p>Date对象以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）</p>
<h4 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h4><p>CST：北京时间是东八区，即GMT+8或者UTC+8，北京时间比UTC时间快8个小时。</p>
<p>有格式显示出来的时间，都与本地相关，即与本地系统设置(或系统默认)的时区相关。</p>
<p>设置时间时，没有指定 time zone，js 将会使用浏览器的 time zone</p>
<p>获取时间时，没有指定 time zone，结果将会转换成浏览器的 time zone</p>
<h4 id="时间转换-☍"><a href="#时间转换-☍" class="headerlink" title="时间转换 ☍"></a>时间转换 <a href="https://www.jianshu.com/p/01cb60d1eeaf" target="_blank" rel="noopener">☍</a></h4><p>JavaScript的<code>new Date()</code>函数生成的是本地时间。</p>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>new Date( )</td>
<td>Mon Feb 13 2017 00:00:00 GMT+0800 (CST)</td>
</tr>
<tr>
<td>toDateString( )</td>
<td>Mon Feb 13 2017</td>
</tr>
<tr>
<td>toGMTString( )</td>
<td>Sun, 12 Feb 2017 16:00:00 GMT</td>
</tr>
<tr>
<td>toISOString( )</td>
<td>2017-02-12T16:00:00.000Z</td>
</tr>
<tr>
<td>toJSON( )</td>
<td>2017-02-12T16:00:00.000Z</td>
</tr>
<tr>
<td>toLocaleDateString( )</td>
<td>2/13/2017</td>
</tr>
<tr>
<td>toLocaleTimeString( )</td>
<td>12:00:00 AM</td>
</tr>
<tr>
<td>toLocaleString( )</td>
<td>2/13/2017, 12:00:00 AM</td>
</tr>
<tr>
<td>toString( )</td>
<td>Mon Feb 13 2017 00:00:00 GMT+0800 (CST)</td>
</tr>
<tr>
<td>toTimeString( )</td>
<td>00:00:00 GMT+0800 (CST)</td>
</tr>
<tr>
<td>toUTCString( )</td>
<td>Sun, 12 Feb 2017 16:00:00 GMT</td>
</tr>
<tr>
<td><strong><em>Date</em></strong>.parse(time)</td>
<td>1555741254000 //unix时间</td>
</tr>
</tbody>
</table>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//date: 2019-02-30T12:21:31.584Z，转为格式: 190203 12:21</span></span><br><span class="line"><span class="keyword">return</span> date.replace(<span class="string">'T'</span>, <span class="string">' '</span>).substring(<span class="number">2</span>, <span class="number">16</span>).split(<span class="regexp">/[-]/</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(time)</span><br><span class="line">  .toLocaleString(<span class="string">'zh'</span>, &#123;</span><br><span class="line">  year: <span class="string">'2-digit'</span>,</span><br><span class="line">  month: <span class="string">'2-digit'</span>,</span><br><span class="line">  day: <span class="string">'2-digit'</span>,</span><br><span class="line">  hour: <span class="string">'2-digit'</span>,</span><br><span class="line">  minute: <span class="string">'2-digit'</span>,</span><br><span class="line">  <span class="comment">// second: '2-digit',</span></span><br><span class="line">  hour12: <span class="literal">false</span>,</span><br><span class="line">&#125;).split(<span class="regexp">/[/]/</span>)</span><br></pre></td></tr></table></figure>
<p>老方法 <a href="http://www.cnblogs.com/carekee/articles/1678041.html" target="_blank" rel="noopener">☍</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTime</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 获取当前日期和时间</span></span><br><span class="line">  <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// Sat Apr 13 2019 05:27:09 GMT+0800 (CST)</span></span><br><span class="line">  <span class="keyword">let</span> y = now.getFullYear()</span><br><span class="line">  <span class="keyword">let</span> m = now.getMonth() + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> d = now.getDate()</span><br><span class="line">  <span class="keyword">let</span> hh = now.getHours()</span><br><span class="line">  <span class="keyword">let</span> mm = now.getMinutes()</span><br><span class="line">  <span class="keyword">let</span> ss = now.getSeconds()</span><br><span class="line">  <span class="keyword">if</span> (m &lt; <span class="number">10</span>) m = <span class="string">'0'</span> + m</span><br><span class="line">  <span class="keyword">if</span> (d &lt; <span class="number">10</span>) d = <span class="string">'0'</span> + d</span><br><span class="line">  <span class="keyword">if</span> (hh &lt; <span class="number">10</span>) hh = <span class="string">'0'</span> + hh</span><br><span class="line">  <span class="keyword">if</span> (mm &lt; <span class="number">10</span>) mm = <span class="string">'0'</span> + mm</span><br><span class="line">  <span class="keyword">if</span> (ss &lt; <span class="number">10</span>) ss = <span class="string">'0'</span> + ss</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>.<span class="subst">$&#123;m&#125;</span>.<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#### </p>
<h3 id="单线程、同步、异步"><a href="#单线程、同步、异步" class="headerlink" title="单线程、同步、异步"></a>单线程、同步、异步</h3><p>javascript是单线程，所有任务需要排队，任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<p>同步任务是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<p>异步任务是不进入主线程、而进入”任务队列”（task queue）的任务，只有等主线程任务执行完毕，”任务队列”开始通知主线程，请求执行任务，该任务才会进入主线程执行。</p>
<p>异步运行机制如下：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p>
<p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码，异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p>——<a href="https://blog.csdn.net/qq_22855325/article/details/72958345" target="_blank" rel="noopener">js中的同步和异步的个人理解</a></p>
<h4 id="事件冒泡与捕获-☍"><a href="#事件冒泡与捕获-☍" class="headerlink" title="事件冒泡与捕获 ☍"></a>事件冒泡与捕获 <a href="http://www.techweb.com.cn/network/system/2016-12-21/2456556.shtml" target="_blank" rel="noopener">☍</a></h4><p>事件冒泡与捕获是 DOM 中事件传播的两种方式，比如两个一里一外的div注册了相同事件，当点击里层 div 的时候，这两个事件谁先执行。</p>
<p>冒泡事件，由里向外，最里层的元素先执行，然后冒泡到外层。</p>
<p>捕获事件，由外向里，最外层的元素先执行，然后传递到内部。</p>
<p>通过修改 addEventListener的第三个参数，true 为捕获，false 为冒泡(默认为冒泡）</p>
<h5 id="同时出现冒泡和捕获会出现什么结果"><a href="#同时出现冒泡和捕获会出现什么结果" class="headerlink" title="同时出现冒泡和捕获会出现什么结果?"></a>同时出现冒泡和捕获会出现什么结果?</h5><p>浏览器处理时间分为两个阶段，先执行捕获阶段，然后是冒泡阶段，例如3个方块：【1【2【3】】】，1、3为冒泡，2为捕获事件，点3依次执行2、3、1。</p>
<h5 id="默认事件取消与停止冒泡"><a href="#默认事件取消与停止冒泡" class="headerlink" title="默认事件取消与停止冒泡"></a>默认事件取消与停止冒泡</h5><p>有时我们只想执行最内层或最外层的事件，根据内外层关系来把范围更广的事件取消掉（对于新手来说，不取消冒泡，很容易中招的出现 bug)。</p>
<p>取消事件冒泡：event.stopPropagation()  (IE 中window.event.cancelBubble = true)</p>
<p>取消浏览器的默认事件： event.preventDefault()  (IE 中window.event.returnValue = false)</p>
<p>取消默认事件和停止冒泡的区别：浏览器的默认事件取消掉就不会执行啦；冒泡取消的是由外向里(捕获)、由里向外(冒泡)，stop 之后，就不会继续遍历了</p>
<h4 id="console-log-☍"><a href="#console-log-☍" class="headerlink" title="console.log() ☍"></a>console.log() <a href="https://github.com/Mmzer/think/issues/30" target="_blank" rel="noopener">☍</a></h4><p>console.log打印出来的内容并不一定可信。一般对于基本类型<code>number、string、boolean、null、undefined</code>的输出是可信的。但对于<code>Object</code>等引用类型来说，可能会异步执行，导致结果异常，这是由平台控制台I/O 延迟导致的，根据平台不同，可能同步也可能异步执行，是无法确定的。</p>
<p>所以对于一般基本类型的调试，调试时使用console.log来输出内容时，不会存在坑。但调试对象时，最好还是使用打断点(<code>debugger</code>)这样的方式来调试更好。</p>
<p>次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过console.log(JSON.stringify(a))，因为JS中对象是引用类型，每次使用对象时，都只是使用了对象在内存的堆中的引用。</p>
<h4 id="异步循环"><a href="#异步循环" class="headerlink" title="异步循环"></a>异步循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">  (<span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(arr)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  &#125;)(arr.concat() )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arr  '</span> + arr)</span><br><span class="line">  arr.shift()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型判断-☍"><a href="#类型判断-☍" class="headerlink" title="类型判断 ☍"></a>类型判断 <a href="https://juejin.im/post/5b19f96b51882513e9059658" target="_blank" rel="noopener">☍</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>); <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(); <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">// "[object HTMLDocument]"</span></span><br></pre></td></tr></table></figure>
<h3 id="小数位保留"><a href="#小数位保留" class="headerlink" title="小数位保留"></a>小数位保留</h3><h4 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2.446242342</span>;</span><br><span class="line">num = num.toFixed(<span class="number">2</span>);  <span class="comment">// 输出结果为 2.45</span></span><br></pre></td></tr></table></figure>
<h4 id="不四舍五入"><a href="#不四舍五入" class="headerlink" title="不四舍五入"></a>不四舍五入</h4><p>第一种，先把小数变整数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">15.7784514000</span> * <span class="number">100</span>) / <span class="number">100</span>   <span class="comment">// 输出结果为 15.77</span></span><br></pre></td></tr></table></figure>
<p>第二种，当作字符串，使用正则匹配：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="number">15.7784514000</span>.toString().match(<span class="regexp">/^\d+(?:\.\d&#123;0,2&#125;)?/</span>))   <span class="comment">// 输出结果为 15.77,不能用于整数如 10 必须写为10.0000</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果是负数，请先转换为正数再计算，最后转回负数</p>
<h2 id="ES6（ES2015）"><a href="#ES6（ES2015）" class="headerlink" title="ES6（ES2015）"></a>ES6（ES2015）</h2><h3 id="扩展运算符（…）☍"><a href="#扩展运算符（…）☍" class="headerlink" title="扩展运算符（…）☍"></a>扩展运算符（…）<a href="https://blog.csdn.net/qq_30100043/article/details/53391308" target="_blank" rel="noopener">☍</a></h3><p>扩展运算符（ spread ）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过push函数，将一个数组添加到另一个数组的尾部。</span><br><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>
<h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><p>合并数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>
<p>结合解构赋值，用于生成数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[a, ...rest] = list</span><br><span class="line">下面是另外一些例子。</span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest <span class="comment">// []:</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];</span><br><span class="line">first <span class="comment">// "foo"</span></span><br><span class="line">rest <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>函数返回多个值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateFields = readDateFields(database);</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);</span><br></pre></td></tr></table></figure>
<p>将字符串转为真正的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_30100043/article/details/53391308" target="_blank" rel="noopener">查看更多</a></p>
<h3 id="Promise对象-☍"><a href="#Promise对象-☍" class="headerlink" title="Promise对象 ☍"></a>Promise对象 <a href="https://es6.ruanyifeng.com/#docs/promise#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">☍</a></h3><p>Promise对象代表一个异步操作，包含三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。</p>
<p>Promise对象不受外界影响，一旦状态改变，就不会再变；</p>
<p>Promise一旦创建就会立即执行，无法中途取消（英语意思就是“承诺”）；</p>
<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态（非必须）的回调函数。</p>
<h3 id="Iterator（遍历器）-☍"><a href="#Iterator（遍历器）-☍" class="headerlink" title="Iterator（遍历器） ☍"></a>Iterator（遍历器） <a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">☍</a></h3><p>遍历器 的作用有三个：</p>
<p>一是为各种数据结构，提供一个统一的、简便的访问接口；</p>
<p>二是使得数据结构的成员能够按某种次序排列；</p>
<p>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
<p>遍历器为各种不同的数据结构提供统一的访问机制。方便依次处理该数据结构的所有成员。</p>
<p>遍历器对象本质是一个指针对象，每一次调用<code>next</code>方法，都会返回数据结构的下一成员的信息，包含<code>value</code>和<code>done</code>两个属性的对象，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//模拟next方法返回值</span><br><span class="line">var it = makeIterator([&apos;a&apos;, &apos;b&apos;])</span><br><span class="line">function makeIterator(array) &#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      return nextIndex &lt; array.length ?</span><br><span class="line">        &#123;value: array[nextIndex++], done: false&#125; :</span><br><span class="line">        &#123;value: undefined, done: true&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it.next() // &#123; value: &quot;a&quot;, done: false &#125;</span><br><span class="line">it.next() // &#123; value: &quot;b&quot;, done: false &#125;</span><br><span class="line">it.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，它是默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 对象obj具有Symbol.iterator属性，是可遍历的</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.iterator] : function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      next: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: 1,</span><br><span class="line">          done: true</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>数组的<code>Symbol.iterator</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'c', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们</p>
<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。</p>
<h3 id="async-☍"><a href="#async-☍" class="headerlink" title="async ☍"></a>async <a href="http://es6.ruanyifeng.com/#docs/async#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">☍</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> afile = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">await</span> fs.readdir(<span class="string">'/Users/fwk/Downloads/try/b1'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(file1)</span><br><span class="line">  <span class="keyword">await</span> timeout(<span class="number">10000</span>)	<span class="comment">//超时完才执行下面语句</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">await</span> fs.readdir(<span class="string">'/Users/fwk/Downloads/try'</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(file2)</span><br><span class="line">  <span class="keyword">const</span> fileAll = <span class="keyword">await</span> [...file1, ...file2]</span><br><span class="line">  <span class="built_in">console</span>.log(fileAll)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'cccc'</span></span><br><span class="line">&#125;</span><br><span class="line">afile().then(<span class="built_in">console</span>.log) <span class="comment">//cccc</span></span><br></pre></td></tr></table></figure>
<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点：</p>
<ol>
<li>内置执行器，与普通函数使用相同；</li>
<li><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚；</li>
<li>更广的适用性，<code>await</code>后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，会自动转成立即 resolved 的 Promise 对象）。</li>
<li><code>async</code>函数的返回值是 Promise 对象，比 Generator 函数的返回值是 Iterator 对象方便多了，可以用<code>then</code>方法指定下一步的操作</li>
</ol>
<p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>
<h4 id="错误不中断"><a href="#错误不中断" class="headerlink" title="错误不中断"></a>错误不中断</h4><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p>
<p>若不想中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一 try...catch</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：Promise 对象后跟一个catch方法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// 出错了 // hello world</span></span><br></pre></td></tr></table></figure>
<p>继发和顺序执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继发执行</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环为继发执行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//并发执行</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach中为并发执行，可能得到错误结果</span></span><br><span class="line">docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="变量名转字符串"><a href="#变量名转字符串" class="headerlink" title="变量名转字符串"></a>变量名转字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVarNameStr</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(v)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myVar = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(getVarNameStr(&#123;myVar&#125;));<span class="comment">//输出 'myVar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理：</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;  <span class="comment">// 相当于&#123;foo: "bar"&#125; ，es6才支持</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">x = &#123;&#125;</span>) =&gt;</span> &#123; <span class="comment">// 变量打印</span></span><br><span class="line">  <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>.values(x)[<span class="number">0</span>]) !== <span class="string">'[object Object]'</span> <span class="comment">//判断是否为对象类型</span></span><br><span class="line">    ? <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(x)[<span class="number">0</span>] + <span class="string">': '</span> + <span class="built_in">Object</span>.values(x)[<span class="number">0</span>])</span><br><span class="line">    : <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(x, <span class="literal">null</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line">print(&#123; dirPath &#125;) <span class="comment">// 打印变量的值 dirPath: /Users/fwk/Downloads/_test</span></span><br></pre></td></tr></table></figure>
<h3 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSON-☍"><a href="#JSON-☍" class="headerlink" title="JSON ☍"></a>JSON <a href="https://juejin.im/post/5be5b9f8518825512f58ba0e" target="_blank" rel="noopener">☍</a></h2><p>JSON是一种数据格式，不是编程语言，是JavaScript的严格子集。</p>
<p>只支持简单值（数字、字符串、布尔值、null）、对象、数组。</p>
<p>字符串必须使用双引号；对象中属性名必须加双引号；</p>
<p>对象值不能为undefined，转换为JSON时会被删掉；</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="对象转文本"><a href="#对象转文本" class="headerlink" title="对象转文本"></a>对象转文本</h4><p>JSON.stringify( )将JS对象转为 JSON 文本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObj=&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Good"</span>,</span><br><span class="line">    <span class="string">"phone"</span>:<span class="string">"1234567"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jsonText = <span class="built_in">JSON</span>.stringify(jsObj, [<span class="string">"name"</span>, <span class="string">"phone"</span>], <span class="number">2</span>)		</span><br><span class="line"><span class="comment">//参数二为过滤数组，只取其中的对应键值，参数三可格式化显示，数字表示空格缩进，'/t'tab缩进；</span></span><br><span class="line"></span><br><span class="line">jsonText = <span class="built_in">JSON</span>.stringify(jsObj, <span class="function"><span class="keyword">function</span>(<span class="params">key，value</span>)</span>&#123;   <span class="comment">//参数二为过滤函数</span></span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"phone"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(000)"</span>+value</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">"number"</span>)	<span class="comment">//类型是数值就加1</span></span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> value; <span class="comment">//如果你把这个else分句删除，那么结果会是undefined</span></span><br><span class="line">&#125;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="文本转对象"><a href="#文本转对象" class="headerlink" title="文本转对象"></a>文本转对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObj = <span class="built_in">eval</span>(<span class="string">'('</span>+ jsonObjStr +<span class="string">')'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="JSON转为JS对象"><a href="#JSON转为JS对象" class="headerlink" title="JSON转为JS对象"></a>JSON转为JS对象</h4><p>JSON.parse( ) </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObj=&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Good"</span>,</span><br><span class="line">    <span class="string">"phone"</span>:<span class="string">"1234567"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">18</span></span><br><span class="line">    <span class="string">"date"</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">07</span>, <span class="number">07</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jsonText = <span class="built_in">JSON</span>.stringify(jsObj)		<span class="comment">//Date对象变为具体值</span></span><br><span class="line"></span><br><span class="line">jsObCOPY = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key，value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"date"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)	<span class="comment">//还原回Date对象</span></span><br><span class="line">    <span class="keyword">else</span> &#123;	</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="延时（setTimeout）"><a href="#延时（setTimeout）" class="headerlink" title="延时（setTimeout）"></a>延时（setTimeout）</h3><p>延时执行的只有setTimeout中的函数，后面的语句仍会立即执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'时间到'</span>)</span><br><span class="line">&#125;，<span class="number">500</span>)	<span class="comment">//到时间（毫秒）后执行函数</span></span><br></pre></td></tr></table></figure>
<h3 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a><a href="https://www.jianshu.com/p/daf575761bf1" target="_blank" rel="noopener">文件目录操作</a></h3><h4 id="检测文件是否存在"><a href="#检测文件是否存在" class="headerlink" title="检测文件是否存在"></a>检测文件是否存在</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 检测文件是否存在，异步</span><br><span class="line">fs.access(&apos;/etc/passwd&apos;, fs.constants.R_OK | fs.constants.W_OK, (err) =&gt; &#123;</span><br><span class="line">  console.log(err ? &apos;no access!&apos; : &apos;can read/write&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="创建目录、写入、读取文件"><a href="#创建目录、写入、读取文件" class="headerlink" title="创建目录、写入、读取文件"></a>创建目录、写入、读取文件</h4><h5 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 新建目录，0o777为目录读写权限</span><br><span class="line">fs.mkdir(&apos;file&apos;, 0o777, function(err) &#123;</span><br><span class="line">    if (err) throw err</span><br><span class="line">    console.log(&apos;新建文件夹成功&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">fs.writeFile(&apos;./file/1.md&apos;, &apos;写入的内容&apos;, function(err) &#123;</span><br><span class="line">    if (err) throw err</span><br><span class="line">    console.log(&apos;文件写入成功&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 读取文件</span><br><span class="line">fs.readFile(&apos;./file/1.md&apos;, &apos;utf8&apos;, function(err, data) &#123;</span><br><span class="line">    if (err) throw err</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 新建目录</span><br><span class="line">fs.mkdirSync(&apos;file&apos;, 0o777)</span><br><span class="line">console.log(&apos;新建file文件夹成功&apos;)</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">fs.writeFileSync(&apos;file/1.md&apos;, &apos;随便写入一句话吧&apos;, &apos;utf8&apos;)</span><br><span class="line">console.log(&apos;新建文件成功&apos;)</span><br><span class="line"></span><br><span class="line">// 读取文件</span><br><span class="line">var data = fs.readFileSync(&apos;file/1.md&apos;, &apos;utf8&apos;)</span><br><span class="line">console.log(&apos;读取文件：&apos; + data)</span><br></pre></td></tr></table></figure>
<h4 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(&apos;file&apos;, function(err, files) &#123;</span><br><span class="line">    if (err) throw err</span><br><span class="line">    var length = files.length</span><br><span class="line">    console.log(&apos;一共有&apos; + length + &apos;个文件&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="判断是文件还是目录"><a href="#判断是文件还是目录" class="headerlink" title="判断是文件还是目录"></a>判断是文件还是目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(&apos;./fs.js&apos;, function(err, stat) &#123;</span><br><span class="line">    if (stat.isFile())</span><br><span class="line">        console.log(&apos;这是个文件&apos;)</span><br><span class="line">    else if (stat.isDirectory())</span><br><span class="line">        console.log(&apos;这是个目录&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="监听文件"><a href="#监听文件" class="headerlink" title="监听文件"></a>监听文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 监听文件</span><br><span class="line">fs.watchFile(&apos;readme.md&apos;, function(curr, prev) &#123;</span><br><span class="line">    console.log(&apos;the current mtime is: &apos; + curr.mtime)</span><br><span class="line">    console.log(&apos;the previous mtime was: &apos; + prev.mtime)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 解除监听</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    fs.unwatchFile(&apos;readme.md&apos;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>
<h4 id="读写数据流"><a href="#读写数据流" class="headerlink" title="读写数据流"></a>读写数据流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 读取数据流</span><br><span class="line">var file = fs.createReadStream(&apos;readme.md&apos;);</span><br><span class="line">var str = &apos;&apos;</span><br><span class="line">file.on(&apos;data&apos;, function(data) &#123;</span><br><span class="line">    str += data</span><br><span class="line">&#125;)</span><br><span class="line">file.on(&apos;end&apos;, function() &#123;</span><br><span class="line">    console.log(str)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 写入数据流</span><br><span class="line">var file = fs.createWriteStream(&apos;readme.md&apos;, &#123;encoding: &apos;utf8&apos;&#125;)</span><br><span class="line">file.write(&apos;写入一句\n&apos;)</span><br><span class="line">file.write(&apos;再写入一句\n&apos;)</span><br><span class="line">file.write(&apos;最后再来一句&apos;)</span><br><span class="line">file.end()</span><br></pre></td></tr></table></figure>
<h2 id="框架、库"><a href="#框架、库" class="headerlink" title="框架、库"></a>框架、库</h2><p><img src="/-media/javascript学习笔记/image-20180627223633650.png" alt="image-20180627223633650"></p>
<h3 id="vue-对比-react"><a href="#vue-对比-react" class="headerlink" title="vue 对比 react"></a>vue 对比 react</h3><p>vue的学习成本极低，体积更小更快</p>
<p>Vue.js在可读性、可维护性和趣味性之间做到了很好的平衡</p>
<p>感觉 React 从一开始的理念就比V，A更具现代化，也就是函数式编程。</p>
<p>vue的简单导致无法完成一些场景，而且它的路由也是坑比较多，而react其实要灵活的多，而且真的实践了才发现它的思想其实更加明确</p>
<p>vue 需要学模板语言</p>
<p>react需要学 JSX，JSX 代码可读性差</p>
<p><a href="https://www.cnblogs.com/roashley/p/7824411.html" target="_blank" rel="noopener">20171113</a></p>
<p><strong>如果是以下需求选react</strong></p>
<p>1、如果想组件式开发</p>
<p>2、如果想web和wap统一技术栈</p>
<p>3、如果想要代码更可维护和可测试性</p>
<p>4、如果你想要最大的生态系统，想利用丰富的组件库及第三方包</p>
<p>5、如果你想要构建大型应用程序</p>
<p><strong>如果是以下需求选vue</strong></p>
<p>1、如果你喜欢使用模板（ 或需要一些其中的选项）构建应用程序</p>
<p>2、如果是在现有代码基础上快速升级</p>
<p>3、如果你喜欢简单的能正常工作的，想更加灵活性</p>
<p>4、如果你希望你的程序更小更快，想要更快的渲染速度和体积</p>
<p><a href="https://www.zhihu.com/question/31585377/answer/210029249" target="_blank" rel="noopener">2017-08-07</a></p>
<p><img src="/-media/javascript学习笔记/180628_075050.png" alt="180628_075050"></p>
<h4 id="2016-10-21"><a href="#2016-10-21" class="headerlink" title="2016-10-21"></a><a href="https://www.zcfy.cc/article/react-or-vue-which-javascript-ui-library-should-you-be-using-2159.html" target="_blank" rel="noopener">2016-10-21</a></h4><p>vue 2 已发布</p>
<ul>
<li>如果你喜欢用（或希望能够用）模板搭建应用，请使用Vue</li>
<li>如果你喜欢简单和“能用就行”的东西，请使用Vue</li>
<li>如果你的应用需要尽可能的小和快，请使用Vue</li>
<li>如果你计划构建一个大型应用程序，请使用React</li>
<li>如果你想要一个同时适用于Web端和原生App的框架，请选择React</li>
<li>如果你想要最大的生态圈，请使用React</li>
<li>如果你已经对其中一个用得满意了，就没有必要换了</li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>在 JavaScript 中，函数表达式的值是函数本身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span></span><br><span class="line">double.toString(); <span class="comment">// 'x =&gt; x * 2'</span></span><br></pre></td></tr></table></figure>
<p>要将函数应用于某些参数，则必须使用函数调用来调用它。括号即表示调用，没有它们，函数将不会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>在函数式编程中，<strong>reduce</strong>（也称为：fold，accumulate）允许你在一个序列上迭代，并应用一个函数来处理预先声明的累积值和当前迭代到的元素。当迭代完成时，将返回这个累积值。许多其他有用的功能都可以通过 reduce 实现。多数时候，reduce 可以说是处理集合（collection）最优雅的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array.reduce(</span><br><span class="line">  reducer: <span class="function">(<span class="params">accumulator: Any, current: Any</span>) =&gt;</span> Any, <span class="comment">//处理函数，acc默认为初始值，cur依次为数组从左到右各项</span></span><br><span class="line">  initialValue: Any	<span class="comment">//初始值</span></span><br><span class="line">) =&gt; accumulator: Any <span class="comment">//返回累计值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如数组各项求和</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>].reduce(<span class="function">(<span class="params">acc, n</span>) =&gt;</span> acc + n, <span class="number">0</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h4 id="柯里化与函数组合-☍"><a href="#柯里化与函数组合-☍" class="headerlink" title="柯里化与函数组合 ☍"></a>柯里化与函数组合 <a href="https://juejin.im/post/5c1a0d516fb9a049d05daee9" target="_blank" rel="noopener">☍</a></h4><p><strong>柯里化函数</strong>是一种把接受多参数的函数变为接受单一参数的函数，通过使用第一个参数并返回使用余下参数的一系列函数，直到所有的参数都被使用，并且函数应用结束，此时结果就会被返回。</p>
<p><strong>偏函数应用</strong>是一种已经应用一些但非全部参数的函数。函数已经应用的参数被称为<strong>固定参数（Fixed Parameters）</strong>。</p>
<p><strong>无点风格</strong>是一种不需要引用参数的函数定义风格。一般来说，无点函数通过调用返回函数的函数来创建，例如柯里化函数。</p>
<p><strong>柯里化函数对于函数组合非常有用</strong>，因为由于函数组合的需要，你可以把 n 元函数轻松地转换成一元函数形式：管道内的函数必须是单一参数。</p>
<p><strong>数据置后函数</strong>对于函数组合来说非常方便，因为它们可以轻松地被用在无点风格中。</p>
<h4 id="函数式编程使用"><a href="#函数式编程使用" class="headerlink" title="函数式编程使用"></a>函数式编程使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span><br><span class="line"></span><br><span class="line">const trace = label =&gt; value =&gt; &#123;</span><br><span class="line">  console.log(`$&#123; label &#125;: $&#123; value &#125;`);</span><br><span class="line">  return value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const g = n =&gt; n + 1;</span><br><span class="line">const f = n =&gt; n * 2;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">现在函数应用的顺序是从上到下：</span><br><span class="line">*/</span><br><span class="line">const h = pipe(</span><br><span class="line">  g,</span><br><span class="line">  trace(&apos;after g&apos;),</span><br><span class="line">  f,</span><br><span class="line">  trace(&apos;after f&apos;),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">h(20);</span><br><span class="line">/*</span><br><span class="line">after g: 21</span><br><span class="line">after f: 42</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="函数式编程理论"><a href="#函数式编程理论" class="headerlink" title="函数式编程理论"></a>函数式编程理论</h4><p>面向对象编程(OOP)通过封装变化使得代码更易理解。 函数式编程(FP)通过最小化变化使得代码更易理解。 – Michacel Feathers（Twitter）</p>
<p>函数式编程的目的是使用函数来<strong>抽象作用在数据之上的控制流和操作</strong>，从而在系统中<strong>消除副作用</strong>并<strong>减少对状态的改变。</strong> <a href="https://juejin.im/post/5c19c3ffe51d45059b632eef" target="_blank" rel="noopener">☍</a></p>
<p>这些情况常常会产生副作用：</p>
<ul>
<li>改变一个全局的变量、属性或数据结构</li>
<li>改变一个函数参数的原始值</li>
<li>处理用户输入</li>
<li>抛出一个异常</li>
<li>屏幕打印或记录日志</li>
<li>查询 HTML 文档，浏览器的 Cookie 或访问数据库</li>
</ul>
<p>对于纯函数有以下性质：</p>
<ul>
<li>仅取决于提供的输入，而不依赖于任何在函数求值或调用间隔时可能变化的隐藏状态和外部状态。</li>
<li>不会造成超出作用域的变化，例如修改全局变量或引用传递的参数。</li>
</ul>
<p>有一些副作用是难以避免的，与外部的存储系统或 DOM 交互等，但是我们可以通过将其从主逻辑中分离出来，使他们易于管理。</p>
<p>一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，就是<strong>引用透明</strong>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="console-log"><a href="#console-log" class="headerlink" title="console.log()"></a>console.log()</h3><p>使用<code>JSON.stringify</code>将json格式的对象或数组转为字符串输出，这样就可以在console.log时显示全部内容了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(数组或对象), <span class="literal">null</span>, <span class="string">'\t'</span>)) <span class="comment">// '\t' 换行缩进，美化显示</span></span><br></pre></td></tr></table></figure>
<h3 id="单元测试-☍-☍"><a href="#单元测试-☍-☍" class="headerlink" title="单元测试 ☍ ☍"></a>单元测试 <a href="https://www.cnblogs.com/sampapa/p/6963936.html" target="_blank" rel="noopener">☍</a> <a href="https://blog.csdn.net/u012510478/article/details/54728921?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener"><strong>☍</strong></a></h3><p>目的是保证一个系统的基本组成单元（类、模块或方法）能正常工作</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Mocha: Javascript测试框架</p>
<p>chai：断言库，需配合Mocha使用</p>
<p>describe：”测试组”，也称测试块，表示要进行一系列测试，相当于一个group</p>
<p>it：”测试项”，也称测试用例，表示这是”一系列测试”中的一项，相当于item，如何测试？测试逻辑？都是在it的回调函数中实现的</p>
<h4 id="assert断言"><a href="#assert断言" class="headerlink" title="assert断言"></a>assert断言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="power-assert-使用）☍-☍-☍"><a href="#power-assert-使用）☍-☍-☍" class="headerlink" title="power-assert(使用）☍ ☍ ☍"></a>power-assert(使用）<a href="https://github.com/power-assert-js/power-assert" target="_blank" rel="noopener">☍</a> <a href="https://www.jianshu.com/p/41ced3207a0c" target="_blank" rel="noopener">☍</a> <a href="http://www.fly63.com/article/detial/1309" target="_blank" rel="noopener">☍</a></h4><p>完全兼容assert</p>
<p>案例参考：lodash-id test</p>
<p>待续~~</p>
<h4 id="expert-断言"><a href="#expert-断言" class="headerlink" title="expert 断言"></a>expert 断言</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相等或不相等</span></span><br><span class="line">expect(<span class="number">4</span> + <span class="number">5</span>).to.be.equal(<span class="number">9</span>);</span><br><span class="line">expect(<span class="number">4</span> + <span class="number">5</span>).to.be.not.equal(<span class="number">10</span>);</span><br><span class="line">expect(foo).to.be.deep.equal(&#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值为true</span></span><br><span class="line">expect(<span class="string">'everthing'</span>).to.be.ok;</span><br><span class="line">expect(<span class="literal">false</span>).to.not.be.ok;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof</span></span><br><span class="line">expect(<span class="string">'test'</span>).to.be.a(<span class="string">'string'</span>);</span><br><span class="line">expect(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;).to.be.an(<span class="string">'object'</span>);</span><br><span class="line">expect(foo).to.be.an.instanceof(Foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// include</span></span><br><span class="line">expect([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).to.include(<span class="number">2</span>);</span><br><span class="line">expect(<span class="string">'foobar'</span>).to.contain(<span class="string">'foo'</span>);</span><br><span class="line">expect(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">hello</span>: <span class="string">'universe'</span> &#125;).to.include.keys(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line">expect([]).to.be.empty;</span><br><span class="line">expect(<span class="string">''</span>).to.be.empty;</span><br><span class="line">expect(&#123;&#125;).to.be.empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// match</span></span><br><span class="line">expect(<span class="string">'foobar'</span>).to.match(<span class="regexp">/^foo/</span>);</span><br></pre></td></tr></table></figure>
<h4 id="测试块生命周期"><a href="#测试块生命周期" class="headerlink" title="测试块生命周期"></a>测试块生命周期</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在本测试块的所有测试用例之前执行且仅执行一次</span></span><br><span class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 在本测试块的所有测试用例之后执行且仅执行一次</span></span><br><span class="line">  after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在测试块的每个测试用例之前执行（有几个测试用例it，就执行几次）</span></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 在测试块的每个测试用例之后执行（同上）</span></span><br><span class="line">  afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 测试用例</span></span><br><span class="line">  it(<span class="string">'test item1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="用例管理：only和skip"><a href="#用例管理：only和skip" class="headerlink" title="用例管理：only和skip"></a>用例管理：only和skip</h4><p>只想执行某个用例，我们就用only方式调用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'../src/add.js'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'加法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 测试组中可以有多个only方式执行的用例</span></span><br><span class="line">  it.only(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it.only(<span class="string">'1 加 0 应该等于 1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">0</span>)).to.be.equal(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组内有only，非only方式执行的用例不会被执行，切记</span></span><br><span class="line">  it(<span class="string">'1 加 -1 应该等于 0'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">-1</span>)).to.be.equal(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'加法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it.skip(<span class="string">'1 加 0 应该等于 1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">0</span>)).to.be.equal(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="端到端测试"><a href="#端到端测试" class="headerlink" title="端到端测试"></a>端到端测试</h3><p>和单元测试／集成测试相比，E2E测试可以用更少的代码覆盖更多的测试场景，代价则是测试的细致程度不足。</p>
<p><strong>需要注意的是：不是所有项目都适合写E2E测试，</strong>以下几点可以帮助你判断自己的项目适不适用E2E测试。</p>
<ul>
<li>项目周期长。编写E2E测试会消耗不少时间和精力，如果不是长期维护的项目没必要进行这些投入。</li>
<li>项目迭代频率高。如果迭代间隔非常长，有充足的测试时间和人手，那么细致的手动界面测试会更加可靠。</li>
<li>页面结构稳定。E2E测试一般依靠css/xpath选择器作为定位元素的方法，如果页面的dom解构经常变更，那么维护测试用例的成本会上升。</li>
</ul>
<p>此外在以下场景中E2E测试的效果比较好：</p>
<ul>
<li>纯静态页面，最好是连内容都不变的页面。可以通过在浏览器层面做截图，然后比较前后两个迭代版本截图的是否一致来判断变更是否破坏了页面的最终展示或者展示的改变是否和预期一致。</li>
<li>兼容性测试。如果需要测试项目在各种浏览器下的兼容性问题，可以通过E2E测试一次覆盖多个不同浏览器。</li>
<li>交互复杂、交互步骤多。例如一个复杂的多步表单的填写，人工操作成本越大，用E2E自动完成带来的收益就越多。<br><strong>但是要留心，和其他测试一样，如果你的测试流程有数据写入，那么在测试结束后应该清除写入的数据，保证再次运行时又是一个一致的环境。</strong></li>
</ul>
</div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-nav"><a class="pre" href="/2017/12/23/Electron笔记/">Electron 学习笔记</a><a class="next" href="/2017/12/01/hexo 主题定义笔记/">Hexo博客主题定制笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yodu.xyz"></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">有度.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>